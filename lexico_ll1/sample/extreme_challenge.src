// ============================================================================
// DESAFÍO EXTREMO PARA ANALIZADOR LÉXICO, SINTÁCTICO Y SEMÁNTICO
// Este archivo contiene casos complejos y edge cases que ponen a prueba
// todas las capacidades del compilador
// ============================================================================

// --- 1. FUNCIONES RECURSIVAS ANIDADAS Y MUTUA RECURSIÓN ---
function fibonacci(n) {
    if (n <= 1) {
        return n;
    } else {
        return fibonacci(n - 1) + fibonacci(n - 2);
    }
}

// Funciones mutuamente recursivas (potencial error semántico si no se maneja bien)
function esPar(n) {
    if (n == 0) {
        return true;
    } else {
        return esImpar(n - 1);
    }
}

function esImpar(n) {
    if (n == 0) {
        return false;
    } else {
        return esPar(n - 1);
    }
}

// --- 2. EXPRESIONES EXTREMADAMENTE ANIDADAS ---
let expresionCompleja = ((((10 + 5) * 3) - (8 / 2)) + ((15 - 3) * (9 + 1))) / (((5 * 2) + 10) - ((3 + 7) / 2));

// --- 3. OPERADORES LÓGICOS Y COMPARACIONES ENCADENADAS ---
let condicionCompleja = (((x > 5) && (y < 10)) || ((z == 15) && (w != 20))) && (!((a >= 3) || (b <= 7)));

// --- 4. ÁMBITOS (SCOPES) PROFUNDAMENTE ANIDADOS ---
function nivel1() {
    let a = 1;
    
    function nivel2() {
        let b = a + 2;  // Acceso a variable del scope padre
        
        function nivel3() {
            let c = b + 3;  // Acceso a variable del scope abuelo
            
            function nivel4() {
                let d = c + 4;  // Acceso a variable del bisabuelo
                
                function nivel5() {
                    let e = d + 5;  // Scope extremadamente anidado
                    return a + b + c + d + e;  // Acceso a todas las variables ancestros
                }
                
                return nivel5();
            }
            
            return nivel4();
        }
        
        return nivel3();
    }
    
    return nivel2();
}

// --- 5. SHADOWING (VARIABLES CON MISMO NOMBRE EN DIFERENTES SCOPES) ---
let x = 10;

function testShadowing() {
    let x = 20;  // Shadowing de x global
    
    if (x > 15) {
        let x = 30;  // Shadowing de x de la función
        
        while (x > 25) {
            let x = 40;  // Shadowing de x del if
            print(x);  // ¿Cuál x imprime? (40)
            x = x - 1;
        }
        
        print(x);  // ¿Cuál x imprime? (30)
    }
    
    print(x);  // ¿Cuál x imprime? (20)
}

// --- 6. FUNCIONES CON MÚLTIPLES PARÁMETROS Y LLAMADAS COMPLEJAS ---
function operacionCompleja(a, b, c, d, e) {
    return ((a + b) * (c - d)) / e;
}

let resultado1 = operacionCompleja(
    fibonacci(5),
    operacionCompleja(1, 2, 3, 4, 5),
    esPar(10),
    esImpar(7),
    nivel1()
);

// --- 7. ESTRUCTURAS DE CONTROL ANIDADAS ---
function estructurasAnidadas(n) {
    let resultado = 0;
    
    for (let i = 0; i < n; i = i + 1) {
        if (i % 2 == 0) {
            while (resultado < 100) {
                if (resultado > 50) {
                    for (let j = 0; j < i; j = j + 1) {
                        if (j % 3 == 0) {
                            resultado = resultado + j;
                        } else {
                            resultado = resultado - 1;
                        }
                    }
                } else {
                    resultado = resultado + i;
                }
                
                if (resultado > 75) {
                    return resultado;
                }
            }
        } else {
            if (i > 5) {
                while (i < 20) {
                    resultado = resultado + 1;
                    i = i + 1;
                }
            }
        }
    }
    
    return resultado;
}

// --- 8. LLAMADAS A FUNCIONES COMO ARGUMENTOS ---
function sumar(a, b) {
    return a + b;
}

function multiplicar(a, b) {
    return a * b;
}

function restar(a, b) {
    return a - b;
}

let resultadoAnidado = sumar(
    multiplicar(3, 4),
    restar(
        sumar(10, 5),
        multiplicar(2, 3)
    )
);

// --- 9. OPERACIONES CON STRINGS Y DIFERENTES TIPOS ---
let mensaje1 = "Hola";
let mensaje2 = "Mundo";
let numero = 42;
let booleano = true;

let concatenacion = mensaje1 + " " + mensaje2;
// let tiposMezclados = mensaje1 + numero;  // Error semántico: tipo incompatible

// --- 10. VARIABLES NO UTILIZADAS (WARNINGS) ---
let variableNoUsada1 = 100;
let variableNoUsada2 = "nunca usada";
const CONSTANTE_NO_USADA = 3.14159;

function funcionNoLlamada() {
    return 42;
}

// --- 11. ERRORES SEMÁNTICOS COMUNES ---
// let variableIndefinida = otraVariable + 10;  // Error: variable no declarada
// const PI = 3.14; PI = 3.1416;  // Error: reasignación de constante
// let duplicado = 5; let duplicado = 10;  // Error: redeclaración

// --- 12. EXPRESIONES BOOLEANAS COMPLEJAS ---
let verdadero = true;
let falso = false;

let logicaCompleja = ((verdadero && !falso) || (falso && verdadero)) && 
                     (!(verdadero && falso) || (!falso || verdadero));

// --- 13. BUCLES CON CONDICIONES COMPLEJAS ---
let contador = 0;
while ((contador < 100) && ((contador % 2 == 0) || (contador % 3 == 0))) {
    if ((contador % 5 == 0) && (contador > 20)) {
        contador = contador + 3;
    } else {
        contador = contador + 1;
    }
}

// --- 14. FOR LOOPS CON EXPRESIONES COMPLEJAS ---
for (let idx = 0; idx < fibonacci(8); idx = idx + esPar(idx)) {
    let temp = idx * 2;
    
    if (temp > 50) {
        for (let inner = temp; inner > 0; inner = inner - 5) {
            let squared = inner * inner;
            print(squared);
        }
    }
}

// --- 15. OPERADORES UNARIOS MÚLTIPLES ---
let negativo = -10;
let dobleNegacion = --negativo;  // Esto debería ser -(- negativo)
let negacionLogica = !verdadero;
let combinado = !-(-5);

// --- 16. RETURN EN DIFERENTES CONTEXTOS ---
function conMultiplesReturns(n) {
    if (n < 0) {
        return -1;
    }
    
    if (n == 0) {
        return 0;
    }
    
    for (let i = 0; i < n; i = i + 1) {
        if (i > 10) {
            return i;
        }
    }
    
    return n * 2;
}

// --- 17. FUNCIONES QUE SE LLAMAN A SÍ MISMAS CON DIFERENTES ARGUMENTOS ---
function factorial(n) {
    if (n <= 1) {
        return 1;
    }
    return n * factorial(n - 1);
}

let fact5 = factorial(5);  // 120
let fact10 = factorial(factorial(3));  // factorial(6) = 720

// --- 18. COMPARACIONES ENCADENADAS CON DIFERENTES OPERADORES ---
let a = 5;
let b = 10;
let c = 15;
let d = 20;

let comparacion = ((a < b) && (b < c)) && ((c < d) || (a == b));

// --- 19. BLOQUES VACÍOS Y EDGE CASES ---
if (verdadero) {
    // Bloque casi vacío
    let x = 1;
}

while (falso) {
    // Este bloque nunca se ejecuta
    let imposible = 999;
}

// --- 20. CADENAS DE ASIGNACIONES ---
let v1 = 10;
let v2 = v1;
let v3 = v2;
let v4 = v3;
v1 = v2 = v3 = v4;  // Asignaciones encadenadas

// --- 21. FUNCIONES BUILT-IN CON ARGUMENTOS COMPLEJOS ---
print(fibonacci(5) + factorial(4));
print(sumar(multiplicar(2, 3), restar(10, 5)));

let entrada = input();
let numeroEntrada = parseInt(entrada);

// --- 22. VARIABLES CON NOMBRES SIMILARES (CONFUSIÓN) ---
let variable = 10;
let Variable = 20;  // Diferente por mayúscula
let variabLe = 30;  // Diferente por mayúscula en medio
let variabl3 = 40;  // Con número

// --- 23. PROGRAMA PRINCIPAL QUE USA TODO ---
function programaPrincipal() {
    let resultado = 0;
    
    // Llamar todas las funciones complejas
    resultado = resultado + fibonacci(10);
    resultado = resultado + nivel1();
    resultado = resultado + estructurasAnidadas(5);
    resultado = resultado + factorial(5);
    
    // Operaciones complejas
    if ((resultado > 100) && (resultado < 1000)) {
        for (let i = 0; i < 10; i = i + 1) {
            resultado = resultado + conMultiplesReturns(i);
        }
    }
    
    // Funciones mutuamente recursivas
    if (esPar(resultado)) {
        print("El resultado es par");
    } else {
        print("El resultado es impar");
    }
    
    return resultado;
}

// --- EJECUTAR EL PROGRAMA ---
let resultadoFinal = programaPrincipal();
print("Resultado final: ");
print(resultadoFinal);

// ============================================================================
// FIN DEL DESAFÍO EXTREMO
// 
// Este archivo pone a prueba:
// ✓ Análisis Léxico: múltiples tipos de tokens, operadores, identificadores
// ✓ Análisis Sintáctico: anidamiento profundo, precedencia de operadores
// ✓ Análisis Semántico: scopes complejos, shadowing, recursión mutua,
//   verificación de tipos, funciones no usadas, variables no declaradas
// ============================================================================
